unit uShellController;

interface

uses
   uConnectionParameters,

   WinSock,         Winapi.WinSock2,
   ShellAPI, Windows, SysUtils, System.Classes;

type
  //u_long = Cardinal;

  TShellController = class
    private


    public
      class procedure InitializeServer(AParams : TConnectionParameters);
      class procedure StopServer(APathBin : String; APathData : String);
      class procedure UpdatePgHbaAuthToTrust(AParams: TConnectionParameters);

      class function IsServerRunning(AParams : TConnectionParameters): Boolean;
      class function ListDatabases(AParams : TConnectionParameters): TStringList;
  end;

implementation

{ TShellController }


class procedure TShellController.InitializeServer(AParams : TConnectionParameters);
var
  StartupInfo: TStartupInfo;
  ProcessInfo: TProcessInformation;
  CmdLine: string;
  AppPath: string;
begin
  ZeroMemory(@StartupInfo, SizeOf(StartupInfo));
  StartupInfo.cb := SizeOf(StartupInfo);
  StartupInfo.dwFlags := STARTF_USESHOWWINDOW;
  StartupInfo.wShowWindow := SW_HIDE;

  AppPath := IncludeTrailingPathDelimiter(AParams.PathBin) + 'pg_ctl.exe';

  CmdLine := Format('"%s" -D "%s" start -o "-p %s"', [AppPath, AParams.PathData, AParams.Port]);

  if not CreateProcess(nil, PChar(CmdLine), nil, nil, False, 0, nil, nil, StartupInfo, ProcessInfo) then
    raise Exception.CreateFmt('Erro ao iniciar o servidor: %s', [SysErrorMessage(GetLastError)]);

  // Fecha os handles do processo (o processo segue rodando em segundo plano)
  CloseHandle(ProcessInfo.hProcess);
  CloseHandle(ProcessInfo.hThread);
end;


class procedure TShellController.StopServer(APathBin : String; APathData : String);
var
  StartupInfo: TStartupInfo;
  ProcessInfo: TProcessInformation;
  CmdLine: string;
  AppPath: string;
begin
  ZeroMemory(@StartupInfo, SizeOf(StartupInfo));
  StartupInfo.cb := SizeOf(StartupInfo);
  StartupInfo.dwFlags := STARTF_USESHOWWINDOW;
  StartupInfo.wShowWindow := SW_HIDE;

  AppPath := IncludeTrailingPathDelimiter(APathBin) + 'pg_ctl.exe';

  CmdLine := Format('"%s" -D "%s" stop', [AppPath, APathData]);

  if not CreateProcess(nil, PChar(CmdLine), nil, nil, False, 0, nil, nil, StartupInfo, ProcessInfo) then
    raise Exception.CreateFmt('Erro ao parar o servidor: %s', [SysErrorMessage(GetLastError)]);

  CloseHandle(ProcessInfo.hProcess);
  CloseHandle(ProcessInfo.hThread);
end;


class function TShellController.IsServerRunning(AParams : TConnectionParameters): Boolean;
var
  AppPath, CmdLine: string;
  SecurityAttr: TSecurityAttributes;
  ReadPipe, WritePipe: THandle;
  StartupInfo: TStartupInfo;
  ProcessInfo: TProcessInformation;
  Buffer: array[0..255] of AnsiChar;
  BytesRead: DWORD;
  Output: string;
begin
  Result := False;
  AppPath := IncludeTrailingPathDelimiter(AParams.PathBin) + 'pg_ctl.exe';
  CmdLine := Format('"%s" -D "%s" status', [AppPath, AParams.PathData]);

  // Configura os pipes para capturar a saída
  SecurityAttr.nLength := SizeOf(SecurityAttr);
  SecurityAttr.bInheritHandle := True;
  SecurityAttr.lpSecurityDescriptor := nil;

  if not CreatePipe(ReadPipe, WritePipe, @SecurityAttr, 0) then
    Exit;

  ZeroMemory(@StartupInfo, SizeOf(StartupInfo));
  StartupInfo.cb := SizeOf(StartupInfo);
  StartupInfo.dwFlags := STARTF_USESTDHANDLES or STARTF_USESHOWWINDOW;
  StartupInfo.wShowWindow := SW_HIDE;
  StartupInfo.hStdOutput := WritePipe;
  StartupInfo.hStdError := WritePipe;

  if not CreateProcess(nil, PChar(CmdLine), nil, nil, True, 0, nil, nil, StartupInfo, ProcessInfo) then
  begin
    CloseHandle(ReadPipe);
    CloseHandle(WritePipe);
    Exit;
  end;

  CloseHandle(WritePipe);

  Output := '';
  repeat
    FillChar(Buffer, SizeOf(Buffer), 0);
    ReadFile(ReadPipe, Buffer, SizeOf(Buffer) - 1, BytesRead, nil);
    if BytesRead > 0 then
      Output := Output + string(AnsiString(Buffer));
  until BytesRead = 0;

  CloseHandle(ReadPipe);
  CloseHandle(ProcessInfo.hProcess);
  CloseHandle(ProcessInfo.hThread);

  Result := (Pos('server is running', LowerCase(Output)) > 0) or
            (Pos('servidor está executando', LowerCase(Output)) > 0);

end;


class function TShellController.ListDatabases(AParams : TConnectionParameters): TStringList;
var
  AppPath, CmdLine: string;
  SecurityAttr: TSecurityAttributes;
  ReadPipe, WritePipe: THandle;
  StartupInfo: TStartupInfo;
  ProcessInfo: TProcessInformation;
  Buffer: array[0..255] of AnsiChar;
  BytesRead: DWORD;
  Output, Line: string;
  SL: TStringList;
  i: Integer;
begin
  Result := TStringList.Create;
  AppPath := IncludeTrailingPathDelimiter(AParams.PathBin) + 'psql.exe';

  SetEnvironmentVariable('PGPASSWORD', PChar(AParams.Password));

  CmdLine := Format('"%s" -U %s -p %s -d postgres -c "SELECT datname FROM pg_database WHERE datistemplate = false;"',
    [AppPath, AParams.User, AParams.Port]);

  SecurityAttr.nLength := SizeOf(SecurityAttr);
  SecurityAttr.bInheritHandle := True;
  SecurityAttr.lpSecurityDescriptor := nil;

  if not CreatePipe(ReadPipe, WritePipe, @SecurityAttr, 0) then
    Exit;

  ZeroMemory(@StartupInfo, SizeOf(StartupInfo));
  StartupInfo.cb := SizeOf(StartupInfo);
  StartupInfo.dwFlags := STARTF_USESTDHANDLES or STARTF_USESHOWWINDOW;
  StartupInfo.wShowWindow := SW_HIDE;
  StartupInfo.hStdOutput := WritePipe;
  StartupInfo.hStdError := WritePipe;

  if not CreateProcess(nil, PChar(CmdLine), nil, nil, True, 0, nil, nil, StartupInfo, ProcessInfo) then
  begin
    CloseHandle(ReadPipe);
    CloseHandle(WritePipe);
    Exit;
  end;

  CloseHandle(WritePipe);

  Output := '';
  repeat
    FillChar(Buffer, SizeOf(Buffer), 0);
    ReadFile(ReadPipe, Buffer, SizeOf(Buffer) - 1, BytesRead, nil);
    if BytesRead > 0 then
      Output := Output + string(AnsiString(Buffer));
  until BytesRead = 0;

  CloseHandle(ReadPipe);
  CloseHandle(ProcessInfo.hProcess);
  CloseHandle(ProcessInfo.hThread);

  SL := TStringList.Create;
  try
    SL.Text := Output;
    for i := 0 to SL.Count - 1 do
    begin
      Line := Trim(SL[i]);
      if (Line <> '') and (Pos('|', Line) = 0) and (Pos('datname', LowerCase(Line)) = 0)
         and (not Line.StartsWith('-')) and (not Line.StartsWith('(')) then
        Result.Add(Line);
    end;
  finally
    SL.Free;
  end;


  SetEnvironmentVariable('PGPASSWORD', nil);
end;


class procedure TShellController.UpdatePgHbaAuthToTrust(AParams : TConnectionParameters);
var
  FilePath: string;
  FileLines: TStringList;
  I: Integer;
  Modified: Boolean;
begin
  FilePath := IncludeTrailingPathDelimiter(AParams.PathData) + 'pg_hba.conf';

  if not FileExists(FilePath) then
    raise Exception.CreateFmt('"pg_hba.conf" file not found at: %s', [FilePath]);

  FileLines := TStringList.Create;
  try
    FileLines.LoadFromFile(FilePath);
    Modified := False;

    for I := 0 to FileLines.Count - 1 do
    begin

      if (not FileLines[I].Trim.StartsWith('#')) and
         ((Pos('md5', FileLines[I]) > 0) or (Pos('scram-sha-256', FileLines[I]) > 0)) then
      begin
        FileLines[I] := StringReplace(FileLines[I], 'md5', 'trust', [rfReplaceAll]);
        FileLines[I] := StringReplace(FileLines[I], 'scram-sha-256', 'trust', [rfReplaceAll]);
        Modified := True;
      end;

    end;

    if Modified then
    begin
      FileLines.SaveToFile(FilePath);
    end;


  finally
    FileLines.Free;
  end;
end;


end.

// comandos nos binarios

// C:\Program Files\PostgresSQL\9.5\bin\pg_ctl -D C:\BACKUP\Ink\9.5\data start


// pg_ctl.exe -D caminho\pasta\data start -o "-p 5432"


// psql.exe -U usuario -p 5432 -l // -l para listar os bancos

